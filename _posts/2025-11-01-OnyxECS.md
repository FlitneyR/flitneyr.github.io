---
title: Onyx's ECS. From the top down, and the bottom up
layout: post
---

Onyx employs a query driven ECS. This pattern is not all that new, with its roots in MVC software architecture.
Though not traditionally used in games, it has been gaining traction as of late, as an alternative to the Actor/GameObject architecture.
In this article I'll try and explain a bit about the motivations behind query driven ECS; the practicalities of using it;
and a little about the challenges of implementing it.

Contents:
- [Motivation](#motivation)
- [Using a Query Driven ECS](#using-a-query-driven-ecs)
- [Implementing a Query Driven ECS](#implementing-a-query-driven-ecs)

## Motivation

You're likely already familiar with the MVC architecture, which divides a program into three main components:
- Model - the state of the program
- View - represents the state to the user / processes user input
- Controller - how the data is evolved over time / in reaction to user input

Typically, gameplay logic favours patterns that more closely couple behaviour with types.
Think, for example, of Actors in UE, or Components in Unity, which - though they do allow for separate concerns
to be divided into separate components - combine data and behaviour into the same classes.

Query driven ECS instead presents a variation of the MVC pattern suited for games:
- The ECS World (Model) - stores the state of the world
- Input, Rendering, and Audio systems (View) - takes input from the user / renders the game world
- ECS Systems (Controller) - queries the ECS world for certain entities, and updates them according to certain rules

## Using a Query Driven ECS

Let's say we want to make a stealth game. In our game we want some enemy NPCs who patrol along some predefined waypoints.
We also want to render these NPCs in a mini map, showing their vision cone, and whether they are aware of the player.

First we want to define the context of our systems. These will be structs passed to our systems by reference or const reference. They provide a way to pass
data into/out of the ECS, as well as between systems.

{% highlight c++ linenos %}
// stores the game's difficulty settings
struct DifficultySettings
{
    // how quickly do AI become aware / forget about things
    f32 awarenessRate;
    f32 awarenessDecayRate;

    // at what point of awareness do we enter certain AI states
    f32 investigationAwarenessThreshold;
    f32 combatAwarenessThreshold;
};

// caches occluder data
struct VisibilityTester
{
    // ...

    void AddOccluder( const Transform& transform, const Occluder& occluder );
    bool IsOccluded( vec3 from, vec3 to ) const;
};

// context to send to the mini-map renderer
struct MiniMapData
{
    // ...

    void AddVisionCone( vec3 position, vec3 direction, f32 field_of_view, f32 range_of_view, Colour colour );
};
{% endhighlight %}

Next we define our components. These are "owned" by specific entities.
A proper implementation would also need to define a `COMPONENT_REFLECTOR` for each of these so the the component can be added in the editor,
serialised, and deserialised. But that is outside the scope of this article, so it has been omitted. As have most of the bodies of these structs,
as the specifics of their implementation are also unimportant for this article.

{% highlight c++ linenos %}
// component that stores the information needed to control AI characters
struct AIController
{
    // ...

    EntityID nextWayPoint;

    enum State
    {
        Idle,
        Investigation,
        Combat
    };

    State GetCurrentState() const;
    f32 GetFieldOfView() const;
    f32 GetRangeOfView() const;

    // update this AI's awareness of another entity
    void UpdateAwareness( const DifficultySettings& difficulty_settings, EntityID other_entity, f32 distance, bool can_see, f32 delta_time );
    f32 GetAwarenessOf( EntityID other_entity ) const;

    // which entity is this AI most aware of
    EntityID GetEntityMostAwareOf() const;
};

// component that stores the information needed to update player characters
struct PlayerController;

// component that stores generic character information
struct Character;

// component that stores the position, rotation, and scale of an entity
struct Transform;

// component that tags an entity as a waypoint for an AI to patrol
struct WayPoint
{
    EntityID nextWayPoint;
};

// component that defines the shape of an entity that blocks line of sight
struct Occluder;
{% endhighlight %}

Now for the fun part! The actual systems.

In Onyx, a system is defined by a function which takes one `onyx::ecs::Context< ... >` argument, followed by any number of `const onyx::ecs::Query< ... >&` arguments.
These define what context, and which sets of entities, the system will interact with.

The types within `onyx::ecs::Query` define which entities are a valid match for the query,
and how we can view/modify the resulting entities that the query finds.

| Query Component Type | Resulting variable | Description                                                                                           |
| -------------------- | ------------------ | ----------------------------------------------------------------------------------------------------- |
| `Read`               | `const T&`         | Component **must** be present on any entity returned by the query<br>System **must not** modify it    |
| `Write`              | `T&`               | Component **must** be present on any entity returned by the query<br>System **may** modify it         |
| `ReadOptional`       | `const T*`         | Component **may** be present on any entity returned by the query<br>System **must not** modify it     |
| `WriteOptional`      | `T*`               | Component **may** be present on any entity returned by the query<br>System **may** modify it          |

Each `onyx::ecs::Query< ... >` contains a set of `onyx::ecs::Query< ... >::Result`s.

These components can be accessed in one of two ways. Via `query_result.Get< T >()`, or all components can be retrieved at once with the pattern:<br>`auto [ entity_id, component_1, component_2, ... ] = query_result.Break()`.

{% highlight c++ linenos %}
void UpdateVisibilityTester(
    // this system needs to update the visibility tester
    onyx::ecs::Context< VisibilityTester > ctx,

    // this system needs to read information about occluders, and their transforms
    const onyx::ecs::Query<
        onyx::ecs::Read< Transform >,
        onyx::ecs::Read< Occluder >
    >& occluders
) {
    auto [ visibility_tester ] = ctx.Break();

    for ( auto& entity : occluders )
    {
        auto [ id, transform, occluder ] = entity.Break();

        visibility_tester.AddOccluder( transform, occluder );
    }
}

void UpdateAIAwareness(
    // this system needs tick information, difficulty information, and to check if one point in the world can see another
    onyx::ecs::Context<
        const onyx::Tick,
        const DifficultySettings,
        const VisibilityTester
    > ctx,

    // this system needs to read the position of the AI, and update the AIController
    const onyx::ecs::Query<
        onyx::ecs::Read< Transform >,
        onyx::ecs::Write< AIController >
    >& ai_entities,

    // this system needs to know where the player is
    const onyx::ecs::Query<
        onyx::ecs::Read< Transform >,
        onyx::ecs::Read< PlayerController >
    >& players
) {
    auto [ tick, difficulty_settings, visibility_tester ] = ctx.Break();

    for ( auto& ai : ai_entities )
    {
        auto [ ai_id, ai_transform, ai_controller ] = ai.Break();

        for ( auto& player : players )
        {
            auto [ player_id, player_transform, player_controller ] = player.Break();

            const f32 distance = GetDistanceBetween( ai_transform.GetPosition(), player_transform.GetPosition() );
            const f32 angle = GetAngleBetween( ai_transform.GetForward(), player_transform.GetPosition() - ai_transform.GetPosition() );
            const bool is_looking_at = angle <= ai_controller.GetFieldOfView();
            const bool has_line_of_sight = !visibility_tester.IsOccluded( ai_transform.GetPosition(), player_transform.GetPosition() );

            ai_controller.UpdateAwareness( difficulty_settings, player_id, distance, is_looking_at && has_light_of_sight, tick.DeltaTime() );
        }
    }
}

void CollectVisionCones(
    // this system needs to write to a MiniMapData struct
    onyx::ecs::Context< MiniMapData > ctx,

    // this system needs to read the transform and ai controller of the ai entities
    const onyx::ecs::Query<
        onyx::ecs::Read< Transform >,
        onyx::ecs::Read< AIController >
    >& ai_entities
) {
    auto [ mini_map_data ] = ctx.Break();

    for ( auto& ai : ai_entities )
    {
        auto [ ai_id, ai_transform, ai_controller ] = ai.Break();

        Colour vision_cone_colour = Colour::white;
        switch ( ai_controller.GetCurrentState() )
        {
            case AIController::Investigate: vision_cone_colour = Colour::Orange; break;
            case AIController::Combat: vision_cone_colour = Colour::Red; break;
        }

        mini_map_data.AddVisionCone(
            ai_transform.GetPosition(),
            ai_transform.GetForward(),
            ai_controller.GetFieldOfView(),
            ai_controller.GetRangeOfView(),
            vision_cone_colour
        );
    }
}

void UpdateAIMovement(
    // this system doesn't need any additional context, but we still need this argument for it to compile
    onyx::ecs::Context<> ctx,

    const onyx::ecs::Query<
        onyx::ecs::Read< Transform >,
        onyx::ecs::Read< AIController >,
        onyx::ecs::Write< Character >
    >& ai_entities,

    const onyx::ecs::Query<
        onyx::ecs::Read< Transform >,
        onyx::ecs::Read< WayPoint >
    >& waypoints,

    const onyx::ecs::Query<
        onyx::ecs::Read< Transform >
    >& entities
) {
    for ( auto& ai : ai_entities )
    {
        auto [ ai_id, ai_transform, ai_controller, ai_character ] = ai.Break();

        switch ( ai_controller.GetCurrentState() )
        {
            case AIController::Idle: { // continue patrolling
                auto* waypoint_entity = waypoints.Get( ai_controller.nextWayPoint );

                // check if we've already reached this waypoint, and need to move to the next one
                if ( waypoint_entity )
                {
                    auto [ waypoint_id, waypoint_transform, waypoint ] = waypoint_entity->Break();

                    if ( ai_character.HasReached( waypoint_transform.GetPosition() ) )
                        waypoint_entity = waypoint_entities.Get( waypoint.nextWayPoint );
                }

                // move to the next waypoint
                if ( waypoint_entity )
                {
                    auto [ waypoint_id, waypoint_transform, waypoint ] = waypoint_entity->Break();

                    ai_character.WalkTowards( waypoint_transform.GetPosition() );
                }
                break;
            }
            case AIController::Investigate: { // walk towards the entity you are most aware of
                ai_character.WalkTowards( ai_controller.GetEntityMostAwareOf() );
                break;
            }
            case AIController::Combat: { // run towards the entity you are most aware of
                ai_character.RunTowards( ai_controller.GetEntityMostAwareOf() );
                break;
            }
        }
    }
}
{% endhighlight %}

Then, adding these systems to our game might look something like this:

{% highlight c++ linenos %}
onyx::ecs::World world;
onyx::ecs::QuerySet tick_query_set( world );
onyx::ecs::QuerySet render_query_set( world );

// ...

using TickSet = onyx::ecs::SystemSet<
    // ...
    const onyx::Tick,
    const DifficultySettings,
    VisibilityTester,
    // ...
>;

using PreRenderSet = onyx::ecs::SystemSet<
    // ...
    MiniMapData,
    // ...
>;

// ...

TickSet pre_update_set( tick_query_set );
TickSet update_set( tick_query_set );
TickSet post_update_set( tick_query_set );

PreRenderSet pre_render_set( render_query_set );

// ...

pre_update_set.AddSystem( UpdateVisibilityTester );
update_set.AddSystem( UpdateAIAwareness );
post_update_set.AddSystem( UpdateAIMovement );

// ...

pre_render_set.AddSystem( CollectVisionCones );

{% endhighlight %}

Then in the main game loop:

{% highlight c++ linenos %}
pre_update_set.Run( /* ... */, tick, difficulty_settings, visibility_tester, /* ... */ );
update_set.Run( /* ... */,tick, difficulty_settings, visibility_tester, /* ... */ );
post_update_set.Run( /* ... */,tick, difficulty_settings, visibility_tester, /* ... */ );
{% endhighlight %}

And in the render update section:

{% highlight c++ linenos %}
if ( IFrameContext* frame_ctx = /* get the frame render context */ )
{
    // ... other render data structs
    MiniMapData mini_map_data;
    // ... other render data structs

    pre_render_set.Run( /* ... */, mini_map_data, /* ... */ );

    // ... other rendering functions
    mini_map_renderer->Render( *frame_context, mini_map_data );
    // ... other rendering functions
}
{% endhighlight %}

Ideally, all tick systems could be put into one tick set, instead of three ( or more ) distinct ones.
This would require a scheduler that is able to avoid any systems writing to any context / components while any other systems are reading them,
and which can be told about dependencies between systems. Using such a scheduler, might look like this:

{% highlight c++ linenos %}
update_set.AddSystem( UpdateVisibilityTester );
update_set.AddSystem( UpdateAIAwareness );
update_set.AddSystem( UpdateAIMovement );

// tell the update set which systems need to run before others
update_set.AddDependency( UpdateVisibilityTester, UpdateAIAwareness );
update_set.AddDependency( UpdateAIAwareness, UpdateAIMovement );
{% endhighlight %}

While not yet implemented in Onyx, this is in my plans.

## Implementing a Query Driven ECS

Coming soon ...
