---
title: Onyx's ECS. From the top down, and the bottom up
layout: post
---

Onyx employs a query driven ECS. This pattern is not all that new, with its roots in MVC software architecture.
Though not traditionally used in games, it has been gaining traction as of late, as an alternative to the Actor/GameObject architecture.
In this article I'll try and explain a bit about the motivations behind query driven ECS; the practicalities of using it;
and a little about the challenges of implementing it.

Contents:
- [Motivation](#motivation)
- [Using a Query Driven ECS](#using-a-query-driven-ecs)
- [Implementing a Query Driven ECS](#implementing-a-query-driven-ecs)

## Motivation

You're likely already familiar with the MVC architecture, which divides a program into three main components:
- Model - the state of the program
- View - represents the state to the user / processes user input
- Controller - how the data is evolved over time / in reaction to user input

Typically, gameplay logic favours patterns that more closely couple behaviour with types.
Think, for example, of Actors in UE, or Components in Unity, which - though they do allow for separate concerns
to be divided into separate components - combine data and behaviour into the same classes.

Query driven ECS instead presents a variation of the MVC pattern suited for games:
- The ECS World (Model) - stores the state of the world
- Input, Rendering, and Audio systems (View) - takes input from the user / renders the game world
- ECS Systems (Controller) - queries the ECS world for certain entities, and updates them according to certain rules

## Using a Query Driven ECS

Let's say we want to make a stealth game. In our game we want some enemy NPCs who patrol along some predefined waypoints.
We also want to render these NPCs in a mini map, showing their vision cone, and whether they are aware of the player.

Implementing such a system in an ECS might look like this:

{% highlight c++ linenos %}
// context that stores the game's difficulty settings
struct DifficultySettings
{
    // how quickly do AI become aware / forget about things
    f32 awarenessRate;
    f32 awarenessDecayRate;

    // at what point of awareness do we enter certain AI states
    f32 investigationAwarenessThreshold;
    f32 combatAwarenessThreshold;
};

// component that stores the information needed to control AI characters
struct AIController
{
    // ...

    EntityID nextWayPoint;

    enum State
    {
        Idle,
        Investigation,
        Combat
    };

    State GetCurrentState() const;
    f32 GetFieldOfView() const;
    f32 GetRangeOfView() const;

    // update this AI's awareness of another entity
    void UpdateAwareness( const DifficultySettings& difficulty_settings, EntityID other_entity, f32 distance, bool can_see, f32 delta_time );
    f32 GetAwarenessOf( EntityID other_entity ) const;

    // which entity is this AI most aware of
    EntityID GetEntityMostAwareOf() const;
};

// component that stores the information needed to update player characters
struct PlayerController;

// component that stores generic character information
struct Character;

// component that stores the position, rotation, and scale of an entity
struct Transform;

// component that tags an entity as a waypoint for an AI to patrol
struct WayPoint
{
    EntityID nextWayPoint;
};

// component that defines the shape of an entity that blocks line of sight
struct Occluder;

// context that caches occluder data
struct VisibilityTester
{
    // ...

    bool IsOccluded( vec3 from, vec3 to ) const;
};

// context that is used to render the mini-map
struct MiniMapData
{
    // ...

    void AddVisionCone( vec3 position, vec3 direction, f32 field_of_view, f32 range_of_view, Colour colour );
};

void UpdateVisibilityTester(
    // this system needs to update the visibility tester
    onyx::ecs::Context< VisibilityTester > ctx,

    // this system needs to read information about occluders
    onyx::ecs::Query<
        onyx::ecs::Read< Transform >,
        onyx::ecs::Read< Occluder >
    >& occluders
) {
    auto [ visibility_tester ] = ctx.Break();

    // iterate through occluders, updating the visibility tester's acceleration structure
    // remove any entities from the visibility tester that no longer exist
}

void UpdateAIAwareness(
    // this system needs to check if one point in the world can see another
    onyx::ecs::Context<
        const onyx::Tick,
        const DifficultySettings,
        const VisibilityTester
    > ctx,

    // this system needs to read the position of the AI, and update the AIController
    const onyx::ecs::Query<
        onyx::ecs::Read< Transform >,
        onyx::ecs::Write< AIController >
    >& ai_entities,

    // this system needs to know where the player is
    const onyx::ecs::Query<
        onyx::ecs::Read< Transform >,
        onyx::ecs::Read< PlayerController >
    >& players
) {
    auto [ tick, difficulty_settings, visibility_tester ] = ctx.Break();

    for ( auto& ai : ai_entities )
    {
        auto [ ai_id, ai_transform, ai_controller ] = ai.Break();

        for ( auto& player : players )
        {
            auto [ player_id, player_transform, player_controller ] = player.Break();

            const f32 distance = GetDistanceBetween( ai_transform.GetPosition(), player_transform.GetPosition() );
            const bool is_looking_at = GetAngleBetween( ai_transform.GetForward(), player_transform.GetPosition() - ai_transform.GetPosition() ) <= ai_controller.GetFieldOfView();
            const bool has_line_of_sight = !visibility_tester.IsOccluded( ai_transform.GetPosition(), player_transform.GetPosition() );

            ai_controller.UpdateAwareness( difficulty_settings, player_id, distance, is_looking_at && has_light_of_sight, tick.DeltaTime() );
        }
    }
}

void CollectVisionCones(
    onyx::ecs::Context< MiniMapData > ctx,

    onyx::ecs::Query<
        onyx::ecs::Read< Transform >,
        onyx::ecs::Read< AIController >
    >& ai_entities
) {
    auto [ mini_map_data ] = ctx.Break();

    for ( auto& ai : ai_entities )
    {
        auto [ ai_id, ai_transform, ai_controller ] = ai.Break();

        Colour vision_cone_colour = Colour::white;
        switch ( ai_controller.GetCurrentState() )
        {
            case AIController::Investigate: vision_cone_colour = Colour::Orange; break;
            case AIController::Combat: vision_cone_colour = Colour::Red; break;
        }

        mini_map_data.AddVisionCone(
            ai_transform.GetPosition(),
            ai_transform.GetForward(),
            ai_controller.GetFieldOfView(),
            ai_controller.GetRangeOfView(),
            vision_cone_colour
        );
    }
}

void UpdateAIMovement(
    // this system doesn't need any additional context, but we still need this for it to compile
    onyx::ecs::Context<> ctx,

    onyx::ecs::Query<
        onyx::ecs::Read< Transform >,
        onyx::ecs::Read< AIController >,
        onyx::ecs::Write< Character >
    >& ai_entities,

    onyx::ecs::Query<
        onyx::ecs::Read< Transform >,
        onyx::ecs::Read< WayPoint >
    >& waypoints,

    onyx::ecs::Query<
        onyx::ecs::Read< Transform >
    >& entities
) {
    for ( auto& ai : ai_entities )
    {
        auto [ ai_id, ai_transform, ai_controller, ai_character ] = ai.Break();

        switch ( ai_controller.GetCurrentState() )
        {
            case AIController::Idle: { // continue patrolling
                auto* waypoint_entity = waypoints.Get( ai_controller.nextWayPoint );

                // check if we've already reached this waypoint, and need to move to the next one
                if ( waypoint_entity )
                {
                    auto [ waypoint_id, waypoint_transform, waypoint ] = waypoint_entity->Break();

                    if ( ai_character.HasReached( waypoint_transform.GetPosition() ) )
                        waypoint_entity = waypoint_entities.Get( waypoint.nextWayPoint );
                }

                // move to the next waypoint
                if ( waypoint_entity )
                {
                    auto [ waypoint_id, waypoint_transform, waypoint ] = waypoint_entity->Break();

                    ai_character.WalkTowards( waypoint_transform.GetPosition() );
                }
                break;
            }
            case AIController::Investigate: { // walk towards the entity you are most aware of
                ai_character.WalkTowards( ai_controller.GetEntityMostAwareOf() );
                break;
            }
            case AIController::Combat: { // run towards the entity you are most aware of
                ai_character.RunTowards( ai_controller.GetEntityMostAwareOf() );
                break;
            }
        }
    }
}
{% endhighlight %}

Then, adding these systems to our game might look something like this:

{% highlight c++ linenos %}
onyx::ecs::World world;
onyx::ecs::QuerySet tick_query_set( world );
onyx::ecs::QuerySet render_query_set( world );

// ...

using TickSet = onyx::ecs::SystemSet<
    // ...
    const onyx::Tick,
    const DifficultySettings,
    VisibilityTester,
    // ...
>;

using PreRenderSet = onyx::ecs::SystemSet<
    // ...
    MiniMapData,
    // ...
>;

// ...

TickSet pre_update_set( tick_query_set );
TickSet update_set( tick_query_set );
TickSet post_update_set( tick_query_set );

PreRenderSet pre_render_set( render_query_set );

// ...

pre_update_set.AddSystem( UpdateVisibilityTester );
update_set.AddSystem( UpdateAIAwareness );
post_update_set.AddSystem( UpdateAIMovement );

// ...

pre_render_set.AddSystem( CollectVisionCones );

{% endhighlight %}

Then in the main game loop:

{% highlight c++ linenos %}
pre_update_set.Run( /* ... */, tick, difficulty_settings, visibility_tester, /* ... */ );
update_set.Run( /* ... */,tick, difficulty_settings, visibility_tester, /* ... */ );
post_update_set.Run( /* ... */,tick, difficulty_settings, visibility_tester, /* ... */ );
{% endhighlight %}

And in the render update section:

{% highlight c++ linenos %}
if ( IFrameContext* frame_ctx = /* get the frame render context */ )
{
    // ... other render data structs
    MiniMapData mini_map_data;
    // ... other render data structs

    pre_render_set.Run( /* ... */, mini_map_data, /* ... */ );

    // ...

    // ... other rendering functions
    mini_map_renderer->Render( *frame_context, mini_map_data );
    // ... other rendering functions

    // ...
}
{% endhighlight %}

Ideally, all tick systems could be put into one tick set, instead of three ( or more ) distinct ones.
This would require a scheduler that is able to avoid any systems writing to any context / components while any other systems are reading them,
and which can be told about dependencies between systems. Using such a scheduler, might look like this:

{% highlight c++ linenos %}
update_set.AddSystem( UpdateVisibilityTester );
update_set.AddSystem( UpdateAIAwareness );
update_set.AddSystem( UpdateAIMovement );

// tell the update set which systems need to run before others
update_set.AddDependency( UpdateVisibilityTester, UpdateAIAwareness );
update_set.AddDependency( UpdateAIAwareness, UpdateAIMovement );
{% endhighlight %}

While not yet implemented in Onyx, this is in my plans.

## Implementing a Query Driven ECS

Coming soon ...
