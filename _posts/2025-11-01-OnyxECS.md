---
title: Onyx's ECS. From the top down, and the bottom up
layout: post
excerpt: Onyx employs a query driven ECS. This pattern is not all that new, with its roots in MVC software architecture. In this article I'll try and explain a bit about the motivations behind query driven ECS; the practicalities of using it; and a little about the challenges of implementing it.
---

{% include note.html content="This article is a work in progress - any feedback is greatly appreciated!
If you have questions, or notice a mistake, please contact me" %}

Onyx employs a query driven ECS. This pattern is not all that new, with its roots in MVC software architecture.
Though not traditionally used in games, it has been gaining traction as of late, as an alternative to the Actor/GameObject architecture.
In this article I'll try and explain a bit about the motivations behind query driven ECS; the practicalities of using it;
and a little about the challenges of implementing it.

Contents:
- [Motivation](#motivation)
- [Usage](#usage)
- [Implementation](#implementation)

## Motivation

You're likely already familiar with the MVC architecture, which divides a program into three main components:
- Model - the state of the program
- View - represents the state to the user / processes user input
- Controller - how the data is evolved over time / in reaction to user input

Typically, gameplay logic favours patterns that more closely couple behaviour with types.
Think, for example, of Actors in UE, or Components in Unity, which - though they do allow for separate concerns
to be divided into separate components - combine data and behaviour into the same classes.

These architectures also imply that gameplay logic applies to single entities at a time. But only a minority of
game objects will be singletons. It is always possible - and there are many cases where it is useful - to iterate over
a large set of similar game objects and apply logic to them. One way to circumvent this restriction is by
creating a "Manager" Actor, which tracks some subset of your Actors, to apply some gameplay logic. But wouldn't
it be nicer if we could just separate logic and data entirely?

Query driven ECS presents a variation of the MVC pattern suited for games:
- The ECS World (Model) - stores the state of the world
- Input, Rendering, and Audio systems (View) - takes input from the user / renders the game world
- ECS Systems (Controller) - queries the ECS world for certain entities, and updates them according to certain rules

## Usage

Let's say we want to make a stealth game. In our game we want some enemy NPCs who patrol along some predefined waypoints.
We also want to render these NPCs in a mini map, showing their vision cone, and whether they are aware of the player.

First we want to define the context of our systems. These will be structs passed to our systems by reference or const reference. They provide a way to pass
data into/out of the ECS, as well as between systems.

{% highlight c++ linenos %}
// stores the game's difficulty settings
struct DifficultySettings
{
    // how quickly do AI become aware / forget about things
    f32 awarenessRate;
    f32 awarenessDecayRate;

    // at what point of awareness do we enter certain AI states
    f32 investigationAwarenessThreshold;
    f32 combatAwarenessThreshold;
};

// caches occluder data
struct VisibilityTester
{
    // ...

    void AddOccluder( const Transform& transform, const Occluder& occluder );
    bool IsOccluded( vec3 from, vec3 to ) const;
};

// context to send to the mini-map renderer
struct MiniMapData
{
    // ...

    void AddVisionCone( vec3 position, vec3 direction, f32 field_of_view, f32 range_of_view, Colour colour );
};
{% endhighlight %}

Next we define our components. These are "owned" by specific entities.
A proper implementation would also need to define a `COMPONENT_REFLECTOR` for each of these so the the component can be added in the editor,
serialised, and deserialised. But that is outside the scope of this article, so it has been omitted. As have most of the bodies of these structs,
as the specifics of their implementation are also unimportant for this article.

{% highlight c++ linenos %}
// component that stores the information needed to control AI characters
struct AIController
{
    // ...

    EntityID nextWayPoint;

    enum State
    {
        Idle,
        Investigation,
        Combat
    };

    State GetCurrentState() const;
    f32 GetFieldOfView() const;
    f32 GetRangeOfView() const;

    // update this AI's awareness of another entity
    void UpdateAwareness( const DifficultySettings& difficulty_settings, EntityID other_entity, f32 distance, bool can_see, f32 delta_time );
    f32 GetAwarenessOf( EntityID other_entity ) const;

    // which entity is this AI most aware of
    EntityID GetEntityMostAwareOf() const;
};

// component that stores the information needed to update player characters
struct PlayerController;

// component that stores generic character information
struct Character;

// component that stores the position, rotation, and scale of an entity
struct Transform;

// component that tags an entity as a waypoint for an AI to patrol
struct WayPoint
{
    EntityID nextWayPoint;
};

// component that defines the shape of an entity that blocks line of sight
struct Occluder;
{% endhighlight %}

Now for the fun part! The actual systems.

In Onyx, a system is defined by a function which takes one `onyx::ecs::Context< ... >` argument, followed by any number of `const onyx::ecs::Query< ... >&` arguments.
These define what context, and which sets of entities, the system will interact with.

The types within `onyx::ecs::Query` define which entities are a valid match for the query,
and how we can view/modify the resulting entities that the query finds.

| Query Component Type | Resulting variable | Description                                                                                           |
| -------------------- | ------------------ | ----------------------------------------------------------------------------------------------------- |
| `Read`               | `const T&`         | Component **must** be present on any entity returned by the query<br>System **must not** modify it    |
| `Write`              | `T&`               | Component **must** be present on any entity returned by the query<br>System **may** modify it         |
| `ReadOptional`       | `const T*`         | Component **may** be present on any entity returned by the query<br>System **must not** modify it     |
| `WriteOptional`      | `T*`               | Component **may** be present on any entity returned by the query<br>System **may** modify it          |

Each `onyx::ecs::Query< ... >` contains a set of `onyx::ecs::Query< ... >::Result`s.

These components can be accessed in one of two ways. Via `query_result.Get< T >()`, or all components can be retrieved at once with the pattern:<br>`auto [ entity_id, component_1, component_2, ... ] = query_result.Break()`.

{% highlight c++ linenos %}
void UpdateVisibilityTester(
    // this system needs to update the visibility tester
    onyx::ecs::Context< VisibilityTester > ctx,

    // this system needs to read information about occluders, and their transforms
    const onyx::ecs::Query<
        onyx::ecs::Read< Transform >,
        onyx::ecs::Read< Occluder >
    >& occluders
) {
    auto [ visibility_tester ] = ctx.Break();

    for ( auto& entity : occluders )
    {
        auto [ id, transform, occluder ] = entity.Break();

        visibility_tester.AddOccluder( transform, occluder );
    }
}

void UpdateAIAwareness(
    // this system needs tick information, difficulty information, and to check if one point in the world can see another
    onyx::ecs::Context<
        const onyx::Tick,
        const DifficultySettings,
        const VisibilityTester
    > ctx,

    // this system needs to read the position of the AI, and update the AIController
    const onyx::ecs::Query<
        onyx::ecs::Read< Transform >,
        onyx::ecs::Write< AIController >
    >& ai_entities,

    // this system needs to know where the player is
    const onyx::ecs::Query<
        onyx::ecs::Read< Transform >,
        onyx::ecs::Read< PlayerController >
    >& players
) {
    auto [ tick, difficulty_settings, visibility_tester ] = ctx.Break();

    for ( auto& ai : ai_entities )
    {
        auto [ ai_id, ai_transform, ai_controller ] = ai.Break();

        for ( auto& player : players )
        {
            auto [ player_id, player_transform, player_controller ] = player.Break();

            const f32 distance = GetDistanceBetween( ai_transform.GetPosition(), player_transform.GetPosition() );
            const f32 angle = GetAngleBetween( ai_transform.GetForward(), player_transform.GetPosition() - ai_transform.GetPosition() );
            const bool is_looking_at = angle <= ai_controller.GetFieldOfView();
            const bool has_line_of_sight = !visibility_tester.IsOccluded( ai_transform.GetPosition(), player_transform.GetPosition() );

            ai_controller.UpdateAwareness( difficulty_settings, player_id, distance, is_looking_at && has_light_of_sight, tick.DeltaTime() );
        }
    }
}

void CollectVisionCones(
    // this system needs to write to a MiniMapData struct
    onyx::ecs::Context< MiniMapData > ctx,

    // this system needs to read the transform and ai controller of the ai entities
    const onyx::ecs::Query<
        onyx::ecs::Read< Transform >,
        onyx::ecs::Read< AIController >
    >& ai_entities
) {
    auto [ mini_map_data ] = ctx.Break();

    for ( auto& ai : ai_entities )
    {
        auto [ ai_id, ai_transform, ai_controller ] = ai.Break();

        Colour vision_cone_colour = Colour::white;
        switch ( ai_controller.GetCurrentState() )
        {
            case AIController::Investigate: vision_cone_colour = Colour::Orange; break;
            case AIController::Combat: vision_cone_colour = Colour::Red; break;
        }

        mini_map_data.AddVisionCone(
            ai_transform.GetPosition(),
            ai_transform.GetForward(),
            ai_controller.GetFieldOfView(),
            ai_controller.GetRangeOfView(),
            vision_cone_colour
        );
    }
}

void UpdateAIMovement(
    // this system doesn't need any additional context, but we still need this argument for it to compile
    onyx::ecs::Context<> ctx,

    const onyx::ecs::Query<
        onyx::ecs::Read< Transform >,
        onyx::ecs::Read< AIController >,
        onyx::ecs::Write< Character >
    >& ai_entities,

    const onyx::ecs::Query<
        onyx::ecs::Read< Transform >,
        onyx::ecs::Read< WayPoint >
    >& waypoints,

    const onyx::ecs::Query<
        onyx::ecs::Read< Transform >
    >& entities
) {
    for ( auto& ai : ai_entities )
    {
        auto [ ai_id, ai_transform, ai_controller, ai_character ] = ai.Break();

        switch ( ai_controller.GetCurrentState() )
        {
            case AIController::Idle: { // continue patrolling
                auto* waypoint_entity = waypoints.Get( ai_controller.nextWayPoint );

                // check if we've already reached this waypoint, and need to move to the next one
                if ( waypoint_entity )
                {
                    auto [ waypoint_id, waypoint_transform, waypoint ] = waypoint_entity->Break();

                    if ( ai_character.HasReached( waypoint_transform.GetPosition() ) )
                        waypoint_entity = waypoint_entities.Get( waypoint.nextWayPoint );
                }

                // move to the next waypoint
                if ( waypoint_entity )
                {
                    auto [ waypoint_id, waypoint_transform, waypoint ] = waypoint_entity->Break();

                    ai_character.WalkTowards( waypoint_transform.GetPosition() );
                }
                break;
            }
            case AIController::Investigate: { // walk towards the entity you are most aware of
                ai_character.WalkTowards( ai_controller.GetEntityMostAwareOf() );
                break;
            }
            case AIController::Combat: { // run towards the entity you are most aware of
                ai_character.RunTowards( ai_controller.GetEntityMostAwareOf() );
                break;
            }
        }
    }
}
{% endhighlight %}

Then, adding these systems to our game might look something like this:

{% highlight c++ linenos %}
onyx::ecs::World world;
onyx::ecs::QuerySet tick_query_set( world );
onyx::ecs::QuerySet render_query_set( world );

// ...

using TickSet = onyx::ecs::SystemSet<
    // ...
    const onyx::Tick,
    const DifficultySettings,
    VisibilityTester,
    // ...
>;

using PreRenderSet = onyx::ecs::SystemSet<
    // ...
    MiniMapData,
    // ...
>;

// ...

TickSet pre_update_set( tick_query_set );
TickSet update_set( tick_query_set );
TickSet post_update_set( tick_query_set );

PreRenderSet pre_render_set( render_query_set );

// ...

pre_update_set.AddSystem( UpdateVisibilityTester );
update_set.AddSystem( UpdateAIAwareness );
post_update_set.AddSystem( UpdateAIMovement );

// ...

pre_render_set.AddSystem( CollectVisionCones );

{% endhighlight %}

Then in the main game loop:

{% highlight c++ linenos %}
pre_update_set.Run( /* ... */, tick, difficulty_settings, visibility_tester, /* ... */ );
update_set.Run( /* ... */,tick, difficulty_settings, visibility_tester, /* ... */ );
post_update_set.Run( /* ... */,tick, difficulty_settings, visibility_tester, /* ... */ );
{% endhighlight %}

And in the render update section:

{% highlight c++ linenos %}
if ( IFrameContext* frame_ctx = /* get the frame render context */ )
{
    // ... other render data structs
    MiniMapData mini_map_data;
    // ... other render data structs

    pre_render_set.Run( /* ... */, mini_map_data, /* ... */ );

    // ... other rendering functions
    mini_map_renderer->Render( *frame_context, mini_map_data );
    // ... other rendering functions
}
{% endhighlight %}

Ideally, all tick systems could be put into one tick set, instead of three ( or more ) distinct ones.
This would require a scheduler that is able to avoid any systems writing to any context / components while any other systems are reading them,
and which can be told about dependencies between systems. Using such a scheduler, might look like this:

{% highlight c++ linenos %}
update_set.AddSystem( UpdateVisibilityTester );
update_set.AddSystem( UpdateAIAwareness );
update_set.AddSystem( UpdateAIMovement );

// tell the update set which systems need to run before others
update_set.AddDependency( UpdateVisibilityTester, UpdateAIAwareness );
update_set.AddDependency( UpdateAIAwareness, UpdateAIMovement );
{% endhighlight %}

While not yet implemented in Onyx, this is in my plans.

## Implementation

The first consideration in creating an ECS is how we will store our components and associate them with Entities.
It would be possible to store them as an Array of Structs, e.g.:

{% highlight c++ linenos %}
struct IComponent
{};

struct Entity
{
    u32 id;
    Map< TypeHash, UniquePtr< IComponent > > components;

    template< Component >
    Component* Get() const
    {
        if ( auto iter = components.find( Component::s_typeHash ); iter != components.end() )
            return static_cast< Component* >( iter->second );

        return nullptr;
    }
};

struct World
{
    Vector< Entity > entities;
};
{% endhighlight %}

And there are some benefits to this. Accessing a certain component of a single entity is quite fast.
But these entities are now scattered around in memory. And running queries requires iterating through every
`Entity` and checking for all relevant components one at a time.

In general, a Struct of Arrays pattern is preferred for better cache hit rates. And in our context, it will allow
us to skip over large swaths of data if a query doesn't care about a certain component type.

{% include note.html content="Some code has been omitted or simplified for brevity: virtual destructors, public/private access specifiers, some standard library shenanigans, other code not directly relevant to this article" %}

First we will define our world

{% highlight c++ linenos %}
struct World
{
    Map< TypeHash, UniquePtr< IComponentTable > > componentTables;
};
{% endhighlight %}

Notice that instead of storing an array of entities, each with a map of components, here we are storing a map
of component types to tables, which in turn will map entity ids to components.

Now we will define `IComponentTable`, essentially a wrapper for an associative array from `EntityID` to a certain
component type. We also need to define an iterator, which we will use later for running queries.

{% highlight c++ linenos %}
struct IComponentTable
{
    struct IIterator
    {
        // which entity is this iterator "looking at"
        virtual EntityID CurrentEntity() const = 0;

        // which entity will this iterator be "looking at" next
        virtual EntityID NextEntity() const = 0;

        // evaluate to true if we are "looking at" a valid entity
        // evaluate to false if we are looking at NoEntity
        virtual operator bool() const = 0;

        void Increment() { m_index++; }

    protected:
        u32 m_index = 0;
    };

    virtual UniquePtr< IIterator > GetGenericIterator() const = 0;

    // this is the only operation that doesn't need to know about the component's actual type
    // so it can be implemented as a virtual function. This operation is also useful for e.g.
    // deleting an entire entity
    virtual void RemoveComponent( EntityID entity ) = 0;

    // has this component table been modified recently
    // by storing this information, we can skip queries where none of the relevant component tables have been modified
    bool m_hasChanged = false;
};
{% endhighlight %}

Then defining a concrete `ComponentTable`:

{% highlight c++ linenos %}
template< Component >
struct ComponentTable : IComponentTable
{
    // a flat map is essentially a Vector< Pair< Key, Value > > where insertion and deletion operations
    // maintain the invariance that all elements are sorted by Key. Lookups are therefore binary searches
    // and the data set can be trivially iterated over in Key order
    FlatMap< EntityID, Component > m_components;

    // insert a component for this entity
    // set m_hasChanged to true
    void AddComponent( EntityID entity, Component&& component );

    // get the component for this entity
    Component* GetComponent( EntityID entity );

    // insert the component for this entity
    // set m_hasChanged to true
    void RemoveComponent( EntityID entity ) override;

    struct Iterator : IIterator
    {
        ComponentTable& table;

        Iterator( ComponentTable& table ) : m_table( table ) {}

        EntityID CurrentEntity() const override
        {
            return m_index < table.Count() ? table.nth( m_index ).key() : NoEntity;
        }

        EntityID NextEntity() const override
        {
            return m_index + 1 < table.Count() ? table.nth( m_index + 1 ).key() : NoEntity;
        }

        operator bool() const override
        {
            return CurrentEntity() != NoEntity;
        }

        Component& GetComponent()
        {
            return m_table.nth( m_index ).value();
        }
    };

    Iterator GetIterator() { return Iterator( *this ); }
    UniquePtr< IIterator > GetGenericIterator() override { return MakeUnique< Iterator >( *this ); }
};
{% endhighlight %}

So we can now iterate through one type of component in our world. But for running our queries, we would like
a way to iterate in lock step. That is to say, iterate through one or more component types, but ensuring that
each iterator is looking at the same entity, or telling us that the current entity doesn't have a component of
that type.

{% highlight c++ linenos %}
struct EntityIterator
{
    EntityID m_currentEntity = EntityID::s_MaxID;
    Map< TypeHash, UniquePtr< IComponentTable::IIterator > > m_iterators;

    // collect relevant iterators from the world and establish what the first entity is that any of these
    // iterators is aware of
    EntityIterator( const World& world, Set< TypeHash >* relevant_components = nullptr )
    {
        for ( auto& [ type, table ] : world.componentTables )
        {
            // skip any component iterators that are not relevant
            if ( relevant_components && !relevant_components->Contains( type ) )
                continue;

            auto iterator = table->GetGenericIterator();

            if ( EntityID entity = iterator->CurrentEntity(); entity != NoEntity )
                m_currentEntity = Min( m_currentEntity, entity );

            m_iterators.Insert( type, std::move( iterator ) );
        }
    }

    // are we "looking at" a valid entity?
    // evaluate to true if any iterators evaluate to true
    operator bool() const;

    // increment the entity iterator
    // the invariant we want to preserve here is that each iterator is either looking at m_currentEntity
    // or, if m_currentEntity doesn't have that component type, the next entity that does have that component type
    EntityIterator& operator ++()
    {
        EntityID entity_iter_next_entity_id = EntityID::s_Max;
        for ( const auto& [ type, iterator ] : m_iterators )
        {
            const EntityID component_iter_current_entity = iterator->CurrentEntity();
            const EntityID component_iter_next_entity = iterator->NextEntity();

            // if this component iterator is looking at an entity "ahead of" the entity iterator as a whole
            // then we should not step over that entity
            if ( component_iter_current_entity > m_currentEntity )
                entity_iter_next_entity_id = Min( entity_iter_next_entity_id, component_iter_current_entity );

            // otherwise, if it is looking at the same entity as the iterator as a whole,
            // make sure we don't step over the next entity that this component iterator wants to look at
            else
                entity_iter_next_entity_id = Min( entity_iter_next_entity_id, component_iter_next_entity );
        }

        m_currentEntity = entity_iter_next_entity_id;

        // progress any iterators that are "behind" the current entity
        for ( auto& [ type, iterator ] : m_iterators )
            if ( *iterator && iterator->CurrentEntity() < m_currentEntity )
                iterator->Increment();

        return *this;
    }

    // get a specific component for this entity
    template< Component >
    Component* Get() const
    {
        // find the relevant component iterator
        UniquePtr< IComponentTable::IIterator >* generic_iter = m_iterators.Get( TypeHash< Component > );
        if ( !generic_iter )
            return nullptr;

        // check that it is looking at this entity, if not then this entity does not have this component
        ComponentTable< Component >::Iterator iter = *static_cast< ComponentTable< Component >::Iterator* >( generic_iter );
        if ( iter.CurrentEntity() != m_currentEntity )
            return nullptr;

        return &iter.GetComponent();
    }
};
{% endhighlight %}

So now we can iterate through a subset of our entities that have certain components, and see what subset of those components
each entity has. This is the basis for how our queries will check for valid entities. But before taking a look at our query
class, we first need to define our Component queries.

These are essentially just a collection of relevant types, and information about certain ways we can query for certain types.

{% highlight c++ linenos %}
template< typename T >
struct Read
{
    using Type = T;
    using Ptr = T*;
    using Arg = const T&;
    static constexpr bool c_isRequired = true;

    static Arg Cast( Ptr ptr ) { return *ptr; }
};

template< typename T >
struct Write
{
    using Type = T;
    using Ptr = T*;
    using Arg = T&;
    static constexpr bool c_isRequired = true;

    static Arg Cast( Ptr ptr ) { return *ptr; }
};

template< typename T >
struct ReadOptional
{
    using Type = T;
    using Ptr = T*;
    using Arg = const T*;
    static constexpr bool c_isRequired = false;

    static Arg Cast( Ptr ptr ) { return ptr; }
};

template< typename T >
struct WriteOptional
{
    using Type = T;
    using Ptr = T*;
    using Arg = T*;
    static constexpr bool c_isRequired = false;

    static Arg Cast( Ptr ptr ) { return ptr; }
};

// some helper functions to map QueryType< T >::Arg back to QueryType< T >
template< typename Arg > struct ComponentType;

template< typename T > struct ComponentType< const T& > { using Type = Read< T >; };
template< typename T > struct ComponentType<       T& > { using Type = Write< T >; };
template< typename T > struct ComponentType< const T* > { using Type = ReadOptional< T >; };
template< typename T > struct ComponentType<       T* > { using Type = WriteOptional< T >; };

template< typename T > using ComponentTypeT = typename ComponentType< T >::Type;
{% endhighlight %}

Now, finally, we can take a look at our query class:

{% highlight c++ linenos %}
struct IQuery
{
    virtual void ResetResults() = 0;
    virtual void Consider( const EntityIterator& entity ) = 0;
    virtual void OnComponentAddedOrRemoved( TypeHash component_type ) = 0;
    virtual void CollectComponentTypes( Set< TypeHash >& component_types ) = 0;

    bool m_needsRerun;
};

template< typename ... Components >
struct Query : IQuery
{
    struct Result
    {
        using Query = Query;

        EntityID m_entity;
        Tuple< typename Components::Ptr ... > m_componentPointers;

        // try to get pointers for each component type
        Result( const EntityIterator& entity )
            : m_entity( entity.m_currentEntity )
            , m_componentPointers( entity.Get< typename Components::Type >() ... )
        {}

        bool IsComplete() const
        {
            // a query result is "complete" i.e. a valid match for the query
            // if every component either is present in the result, or was optional
            return (
                ( !Components::c_isRequired || m_componentPointers.Get< typename Components::Ptr >() != nullptr )
                && ...
            );
        }

        template< typename T >
        T Get() const
        {
            using Component = ComponentTypeT< T >;
            return Component::Cast( m_componentPointers.Get< typename Component::Ptr >() );
        }

        Tuple< const EntityID&, typename Components::Arg ... > Break() const
        {
            return {
                m_entity,
                Component::Cast( m_componentPointers.Get< typename Components::Ptr >() ) ...
            };
        }
    };

    Vector< Result > m_results;
    void ResetResults() override { m_results.clear(); }
    
    void Consider( const EntityIterator& entity ) override
    {
        Result result( entity );
        if ( result.IsComplete() )
            m_results.Push( result );
    }

    void OnComponentAddedOrRemoved( TypeHash component_type ) override
    {
        // we need to rerun if any component type in our queries has been added or removed
        // as this may have invalidated our results, or worse, invalidated our pointers
        m_needsRerun |= ( ( component_type == TypeHash< typename Components::Type > ) || ... );
    }

    CollectComponentTypes( Set< TypeHash >& component_types ) override
    {
        component_types.Insert( TypeHash< typename Components::Type > ... );
    }

    // do a binary search of m_results for a result for this entity
    const Result* Get( EntityID entity ) const;

    // allow for iteration by index
    u32 Count() const { return m_results.Count(); }
    const Result& operator []( u32 index ) const { return m_results[ index ]; }

    // allow for iteration by iterator
    Vector< Result >::Iterator begin() const;
    Vector< Result >::Iterator end() const;
};
{% endhighlight %}

And we need something to manage our queries - make sure we run queries when needed, and don't rerun duplicate queries - for that we need:
- A query manager - A factory that creates queries and makes sure we don't make more than one of the same query. We will add this to our ECS world, since one ECS world doesn't need more than one of any certain query
- A query set - organise running our queries when needed

{% highlight c++ linenos %}
struct QueryManager
{
    template< typename Query >
    SharedPtr< Query > Get()
    {
        const TypeHash query_type_hash = TypeHash< Query >;

        // check if we already have an entry for this query type
        auto iter = m_queries.find( query_type_hash );
        if ( iter == m_queries.end() )
            iter = m_queries.insert( query_type_hash, nullptr ).first;

        // check if the entry has expired / hasn't been initialised yet
        SharedPtr< IQuery > query = iter->second.lock();
        if ( !query )
            iter->second = query = MakeSharedPtr< Query >();

        return query;
    }

    void UpdateNeedsRerun( World& world );

private:
    Map< TypeHash, WeakPtr< IQuery > > m_queries;
};

struct World
{
    Map< TypeHash, UniquePtr< IComponentTable > > componentTables;
    QueryManager m_queryManager;
};

struct QuerySet
{
    World& m_world;
    Map< TypeHash, WeakPtr< IQuery > > m_queries;

    QuerySet( World& world ) : m_world( world ) {}

    template< typename Query >
    SharedPtr< Query > Get()
    {
        const TypeHash query_type_hash = TypeHash< Query >;

        // check if we already have an entry for this query type
        auto iter = m_queries.find( query_type_hash );
        if ( iter == m_queries.end() )
            iter = m_queries.insert( query_type_hash, nullptr ).first;

        // check if the entry has expired / hasn't been initialised yet
        SharedPtr< IQuery > query = iter->second.lock();
        if ( !query )
            iter->second = query = m_world.m_queryManager.Get< Query >();

        return query;
    }

    void Update()
    {
        // remove any queries that are no longer in use
        std::erase_if( m_queries, []( auto pair ) { return pair.second.expired(); } );

        // collect the queries, and component types for those queries
        Vector< SharedPtr< IQuery > > queries_to_run;
        Set< TypeHash > relevant_components;

        // find the queries that need to rerun
        for ( auto [ _hash, _query ] : m_queries )
        {
            if ( auto query = _query.lock() )
            {
                if ( query->m_needsRerun )
                {
                    // reset the query
                    query->m_needsRerun = false
                    query->ClearResults();

                    // add these component types to the component types we need in our iterator
                    query->CollectComponentTypes( relevant_components );

                    queries_to_run.push_back( query );
                }
            }
        }

        // if any queries need to rerun, run them
        if ( !queries_to_run.empty() )
            for ( auto iter = m_world.Iter( &relevant_components ); iter; ++iter )
                for ( auto query : queries_to_run )
                    query->Consider( iter );
    }
};
{% endhighlight %}

By
- Keeping track of when components of each type are added or removed,
- Notifying queries of these added or removed entities,
- Collecting queries that need to rerun,
- Collecting the component types that these queries care about,
- And making an entity iterator that only contains those component types

We can keep our queries up to date, while doing a minimal amount of unnecessary work, e.g.:
- Rerunning queries that are still valid from the previous frame
- Iterating over entities that have none of the components that our queries care about

This means that small, targetted queries can be very efficient. For example, queries that only
care about one or two components that are infrequently used. In the array of structs design, this query
would be one of the most inefficient types of query, having to iterate over every component of every entity, just to find a handful of components.

In the struct of arrays design, this is one of the most efficient types of query, as it will not need to iterate over many entities.

Unfortunately, the reality of the situation is that many queries will end up asking about the same handful of component types.
For example, the Transform component. It turns out, a lot of gameplay systems need to know where stuff is, and most entities will have a Transform.
So every query that asks for a Transform, will have to iterate over most entities, and will have to rerun every time that an entity with a Transform
component is added or removed.

Another drawback of this design is the costs of adding or removing components. Both operations are $$O(n)$$, as they must preserve the order of the components.

Both issues could be alleviated by not storing components in single large blocks of memory, but by storing them in pages instead, and only
rerunning queries over the entities in the pages that have changed.

But we don't want to be manually accessing these queries, and manually running our systems. So the next step is to register our system functions,
connect them with the relevant queries, and them running in parallel.

{% highlight c++ linenos %}
template< typename ... ContextComponents >
struct SystemSet
{
    using IContext = Context< ContextComponents ... >;

    SystemSet( QuerySet& query_set ) : m_querySet( query_set ) {}

    // add a system to run in parallel with everything else
    template< typename Func >
    void AddSystem( Func* callback )
    {
        m_systems.push_back( MakeUnique< System< IContext, Func > >( m_querySet, callback ) );
    }

    void Run( ContextComponents& ... context_components )
    {
        IContext context( context_components ... );

        // for simplicity, I've used OpenMP. But a job queue / worker thread model would be better, especially once
        // these systems are automatically sorted and synchronised
        #pragma omp parallel for
        for ( i32 system_index = 0; system_index < m_systems.size(); ++system_index )
        {
            m_systems[ system_index ]->Run( context );
        }
    }

private:
    QuerySet& m_querySet;
    Vector< UniquePtr< ISystem< IContext > > > m_systems;
};
{% endhighlight %}

But there's quite a bit missing from this. Let's first define `Context< ... >`.

`Context< ... >` will allow us to request certain context arguments from within our systems. This allows systems to be aware of / modify
state outside of the ECS, without making that state global.

{% highlight c++ linenos %}
// here the Components are components of the context, not of an entity
template< typename ... Components >
struct Context
{
	Tuple Components& ... > m_components;

	Context( Components& ... components )
		: m_components( components ... )
	{}

    // this lets us pass in any context that is a super set of this context,
    // so the context passed to the system set doesn't have to exactly match
    // the context requested by any specific system
	template< typename OtherContext >
	Context( OtherContext& other_context )
		: m_components( other_context.template Get< Components >() ... )
	{}

	template< typename T >
	T& Get() const
	{
        // the actual implementation of this function is a bit more complicated to allow it to get const references
        // of non-const members of the tuple. We need a ternary type to select between the const and non-const version
        // depending on which one we have in our tuple
		return m_components.Get< T >();
	}

	Tuple Components& ... > Break() const { return m_components; }
};
{% endhighlight %}

It's the home straight now, just one final step: registering systems

{% highlight c++ linenos %}
template< typename IContext >
struct ISystem
{
	virtual void Run( IContext& context ) const = 0;
};

template< typename IContext, typename Func >
struct System;

template< typename IContext, typename Context, typename ... Queries >
struct System< IContext, void( Context, const Queries& ... ) > : ISystem< IContext >
{
	using Func = void( Context, const Queries& ... );

	System( QuerySet& query_set, Func* callback )
		: m_callback( callback )
		, m_queries( query_set.Get< Queries >() ... )
	{}

	void Run( IContext& context ) const override
    {
        // we create a Context from IContext here, using the template constructor from the previous snippet
        // to act as glue, connecting the generic context passed into the system set to the specific context for this system
        ( *m_callback )( Context( context ), *m_queries.Get< SharedPtr< Queries > >() ... );
    }

private:
	Func* const m_callback;
	Tuple< SharedPtr< Queries > ... > m_queries;
};
{% endhighlight %}
